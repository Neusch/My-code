Design

The purpose of this assignment was to create a file compression algorithm based on Huffman trees and other various data structures that we have studied over the quarter including bit vectors, stacks, and queues. The file compression requires an encoder which can be used by typing ./encode and a decoder that can be used by the command ./decode.

Encode

Encode can take in 4 different options; -i followed by a file name specifies a file to be encoded, -o followed by a file name specifies a file where the encoded file will be written to, -v specifies extra information to be printed about the encoded file, and -p prints the Huffman tree that gets encoded. Encoding starts by reading through a file and creating a histogram of all of the characters in the file. 0x00 and 0xFF are always given at least one in the histogram to ensure that the tree created is not empty. After this, a priority queue is created that enqueues Huffman tree nodes based on the frequency of each character in the histogram. The least frequent items get enqueued to the tail and these are also the first items to be dequeued when the tree is created. The tree gets created by joining the two nodes at the tail and enqueuing this new node back into the priority queue until there is nothing left in the queue. A full Huffman tree has now been created. After this, a call to build code is made which basically just traverses the tree and uses a stack as it goes to make a bit encoding for each character in the tree. When the tree goes left, a 0 is pushed into the stack; when it goes right a 1 is pushed onto the stack, and when the tree goes back up, a pop is called. When it gets to a leaf, aka a character in the tree, the code on the stack is saved. After this, a magic number is written onto the output file, the size of the file is written, the size of the tree is written, the tree is written to the file, and finally, the encoded file is written onto the output. This file is encoded by again traversing the whole file and for each character encountered, the code made from the call to build code is given rather than the character. And finally the files are closed and the allocated memory is freed.

Decode

Decode is basically the opposite of encode and take all of the same arguments as inputs. This program starts opening the input file and reading the magic number, if no magic number is found then there it is not a valid encoded file. Next the file size and tree size are read in, and if the right amount of bytes are not able to be read, then again we know that it is not a valid compressed file. Next, the tree from the encoded file is read in and then recreated using the function load tree. Then the encoded file is read in and the tree is traversed based on the items in the file. If a 0 is found then the tree goes down to the left, and if a one is found the tree goes to the right. This resets to the root each time a leaf is found, along with printing out the character held in this leaf to the output file. This happens for the whole file and then the files are closed, and the allocated memory freed.

Contributions

I worked mainly on the decoder while my partner, Thomas, worked mainly on the encoder. However, both of us worked together to create all of the required data structures, including the Huffman tree, the priority queue, and the stack. We also both went over the outline and the core logic for each of the decoder and encoder before we made them separately along with occasionally helping the other if they came to a bug or error in each of those programs. We used GitHub as a way to share our work and work on the assignment together while still being able to use git.

Thomas was a great partner and we worked very well together. This assignment seemed like it was the easiest one because through our combined brainstorming and collaboration, we were able to think out many of the data structures and other logic efficiently and effectively. Most of our functions worked on the first attempt because of this.
